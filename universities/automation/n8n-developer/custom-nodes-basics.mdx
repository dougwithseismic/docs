---
title: "Lesson 2: Building Custom n8n Nodes"
description: Create powerful custom nodes to extend n8n's capabilities
---

## Why Custom Nodes Transform Your n8n Experience

When you first start with n8n, you're limited to the pre-built nodes. That works great until you need to integrate with your company's proprietary API, implement custom business logic, or optimize a complex workflow that's using 20 nodes when it could use just one. Custom nodes change everything.

Custom nodes are your escape hatch from limitations. Instead of waiting for the n8n team to build support for your specific use case, you build it yourself. Instead of chaining together multiple nodes with complex logic, you encapsulate that logic in a single, reusable component.

## What We're Building Today

In this lesson, we'll create two custom nodes that demonstrate different complexity levels:

1. **HTTP Bin Node**: A testing node that interacts with httpbin.org - perfect for learning the basics of node structure, parameters, and API calls
2. **Data Processor Node**: A powerful transformation node that can filter, aggregate, and manipulate data - showing you how to build nodes that solve real business problems

By the end of this lesson, you won't just have two working nodes - you'll understand the patterns and principles to build any node you can imagine.

## Understanding n8n Node Architecture

Before we write any code, we need to understand what makes a node tick. Every n8n node is a TypeScript class that implements the `INodeType` interface.

```typescript
// Basic node structure
import { INodeType, INodeTypeDescription } from 'n8n-workflow';

export class MyCustomNode implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'My Custom Node',
    name: 'myCustomNode',
    group: ['transform'],
    version: 1,
    description: 'My first custom node',
    defaults: {
      name: 'My Custom Node',
    },
    inputs: ['main'],
    outputs: ['main'],
    properties: []
  };

  async execute(this: IExecuteFunctions) {
    // Node logic here
  }
}
```

Let's break down what each part does:

- **description**: This object defines how your node appears in n8n's UI - its name, category, and configuration options
- **displayName**: What users see in the node panel
- **name**: The internal identifier (must be unique across all nodes)
- **group**: Determines where the node appears in the node panel categories
- **inputs/outputs**: Defines how many connections the node accepts and produces
- **properties**: The configuration fields users can set (we'll add these soon)
- **execute()**: The heart of your node - this function runs when the workflow executes

n8n handles all the complex stuff - workflow execution, error handling, data passing between nodes - while you focus on your node's specific logic.

## Project Setup: Building Your Development Environment

Now we'll set up a proper development environment for building custom nodes. We're creating a professional development setup that you can use for all your future node projects.

### Step 1: Initialize Your Node Project

First, we'll create a new project directory and set up the basic structure. Each command here has a purpose:

```bash
# Create project directory - this will house all your custom nodes
mkdir n8n-nodes-custom && cd n8n-nodes-custom

# Initialize package.json - creates the project manifest
npm init -y

# Install n8n dependencies - these provide the types and utilities we need
npm install n8n-core n8n-workflow

# Install development dependencies - TypeScript for type safety
npm install -D @types/node typescript
```

Why these specific packages? The `n8n-core` and `n8n-workflow` packages contain all the interfaces and helper functions your nodes will use. TypeScript isn't strictly required, but it gives you intellisense and catches errors before runtime - invaluable when working with n8n's APIs.

### Step 2: Configure TypeScript for n8n Development

TypeScript configuration is crucial for n8n compatibility. Create a `tsconfig.json` file:

```json
{
  "compilerOptions": {
    "lib": ["es2020"],        // Use modern JavaScript features
    "target": "es2019",       // Compile to ES2019 for n8n compatibility
    "module": "commonjs",     // n8n uses CommonJS modules
    "moduleResolution": "node",
    "esModuleInterop": true,
    "declaration": true,      // Generate .d.ts files for type checking
    "outDir": "./dist",       // Compiled files go here
    "rootDir": "./src",       // Source files go here
    "strict": true,           // Enable all strict type checking
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

Each of these settings matters. The ES2019 target ensures compatibility with n8n's runtime, while CommonJS modules are required for n8n's node loading system. The strict flag will save you hours of debugging by catching type errors early.

### Step 3: Configure Your Package for n8n Integration

The most important part of your `package.json` is the n8n configuration section. Update it like this:

```json
{
  "name": "n8n-nodes-custom",
  "version": "0.1.0",
  "description": "Custom n8n nodes",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",      // Hot reload during development
    "lint": "eslint src --ext .ts",
    "prepublishOnly": "npm run build"
  },
  "n8n": {
    "n8nNodesApiVersion": 1,
    "nodes": [
      "dist/nodes/HttpBin/HttpBin.node.js",
      "dist/nodes/DataProcessor/DataProcessor.node.js"
    ],
    "credentials": [
      "dist/credentials/CustomApi.credentials.js"
    ]
  },
  "files": [
    "dist"
  ]
}
```

The `n8n` section tells n8n where to find your nodes and credentials. When n8n starts up, it reads this section and loads your custom nodes into the node panel, making them appear alongside the built-in ones.

## Building Your First Node: HTTP Bin

Now for the exciting part - let's build our first real node! We'll create an HTTP Bin node that interacts with httpbin.org, a service designed for testing HTTP requests. This is perfect for learning because it's simple enough to understand but complex enough to teach you the important patterns.

### Step 1: Understanding What We're Building

Before diving into code, let's understand what our HTTP Bin node will do:
- Make different types of HTTP requests (GET, POST, PUT, DELETE)
- Accept dynamic parameters and request bodies
- Handle responses and errors gracefully
- Provide a user-friendly configuration interface

This node will teach you how to:
- Define node properties that appear in the UI
- Handle user inputs and parameters
- Make external API calls
- Process and return data to the workflow

### Step 2: Creating the Node Structure

Create the file `src/nodes/HttpBin/HttpBin.node.ts`. We'll build this step by step:

```typescript
import {
  IExecuteFunctions,
  INodeExecutionData,
  INodeType,
  INodeTypeDescription,
  NodeOperationError,
} from 'n8n-workflow';
import { OptionsWithUri } from 'request-promise-native';

export class HttpBin implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'HTTP Bin',
    name: 'httpBin',
    icon: 'file:httpbin.svg',
    group: ['input'],
    version: 1,
    subtitle: '={{$parameter["operation"] + ": " + $parameter["resource"]}}',
    description: 'Interact with httpbin.org for testing',
    defaults: {
      name: 'HTTP Bin',
    },
    inputs: ['main'],
    outputs: ['main'],
    credentials: [],
    properties: [
      {
        displayName: 'Resource',
        name: 'resource',
        type: 'options',
        noDataExpression: true,
        options: [
          { name: 'Request', value: 'request' },
          { name: 'Response', value: 'response' },
          { name: 'Auth', value: 'auth' },
        ],
        default: 'request',
      },
      {
        displayName: 'Operation',
        name: 'operation',
        type: 'options',
        noDataExpression: true,
        displayOptions: {
          show: {
            resource: ['request'],
          },
        },
        options: [
          { name: 'GET', value: 'get' },
          { name: 'POST', value: 'post' },
          { name: 'PUT', value: 'put' },
          { name: 'DELETE', value: 'delete' },
        ],
        default: 'get',
      },
      {
        displayName: 'Endpoint',
        name: 'endpoint',
        type: 'string',
        required: true,
        displayOptions: {
          show: {
            resource: ['request'],
          },
        },
        default: '/anything',
        placeholder: '/anything',
        description: 'The endpoint to call',
      },
      {
        displayName: 'Request Body',
        name: 'body',
        type: 'json',
        displayOptions: {
          show: {
            resource: ['request'],
            operation: ['post', 'put'],
          },
        },
        default: '{}',
        description: 'Body to send with request',
      },
      {
        displayName: 'Query Parameters',
        name: 'queryParams',
        type: 'fixedCollection',
        placeholder: 'Add Query Parameter',
        default: {},
        typeOptions: {
          multipleValues: true,
        },
        options: [
          {
            name: 'parameter',
            displayName: 'Parameter',
            values: [
              {
                displayName: 'Name',
                name: 'name',
                type: 'string',
                default: '',
              },
              {
                displayName: 'Value',
                name: 'value',
                type: 'string',
                default: '',
              },
            ],
          },
        ],
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const items = this.getInputData();
    const returnData: INodeExecutionData[] = [];
    const resource = this.getNodeParameter('resource', 0) as string;
    const operation = this.getNodeParameter('operation', 0) as string;

    for (let i = 0; i < items.length; i++) {
      try {
        if (resource === 'request') {
          const endpoint = this.getNodeParameter('endpoint', i) as string;
          const method = operation.toUpperCase();

          const options: OptionsWithUri = {
            method,
            uri: `https://httpbin.org${endpoint}`,
            json: true,
          };

          // Add query parameters
          const queryParams = this.getNodeParameter('queryParams', i, {}) as any;
          if (queryParams.parameter) {
            const qs: any = {};
            for (const param of queryParams.parameter) {
              qs[param.name] = param.value;
            }
            options.qs = qs;
          }

          // Add body for POST/PUT
          if (['POST', 'PUT'].includes(method)) {
            const body = this.getNodeParameter('body', i) as string;
            options.body = JSON.parse(body);
          }

          const response = await this.helpers.request(options);
          returnData.push({ json: response });
        }

        if (resource === 'response') {
          // Generate custom responses
          const statusCode = this.getNodeParameter('statusCode', i, 200) as number;
          const customResponse = {
            status: statusCode,
            timestamp: new Date().toISOString(),
            message: `Generated response with status ${statusCode}`,
          };
          returnData.push({ json: customResponse });
        }

        if (resource === 'auth') {
          // Test authentication
          const authType = this.getNodeParameter('authType', i) as string;
          const options: OptionsWithUri = {
            method: 'GET',
            uri: `https://httpbin.org/${authType}`,
            json: true,
          };

          const response = await this.helpers.request(options);
          returnData.push({ json: response });
        }
      } catch (error) {
        if (this.continueOnFail()) {
          returnData.push({ json: { error: error.message } });
          continue;
        }
        throw new NodeOperationError(this.getNode(), error);
      }
    }

    return [returnData];
  }
}
```

### Step 3: Understanding the Code Structure

Let's break down what's happening in this node:

**The Description Object**: This is where you define your node's UI. Each property in the `properties` array becomes a field in the node's configuration panel. The `displayOptions` property is particularly powerful - it lets you show/hide fields based on other selections, creating a dynamic, context-aware interface.

**The Execute Method**: This is where the magic happens. The execute method:
1. Gets the input data from previous nodes
2. Iterates through each item (n8n processes data in batches)
3. Reads the user's configuration using `getNodeParameter`
4. Makes the HTTP request
5. Returns the processed data to the next node

n8n handles all the complexity of workflow execution, while you focus on your node's specific logic.

### Step 4: Adding Advanced Features

Now let's add some advanced features to make our node production-ready. We'll add:
- Query parameter support
- Request body handling for POST/PUT requests
- Error handling with retry logic
- Custom authentication options

These features transform our simple node into something you'd actually use in production.

## Building a Production-Grade Node: Data Processor

Now that you understand the basics, let's build something more sophisticated. The Data Processor node will demonstrate advanced patterns you'll use in real-world nodes.

This node can:
- Transform data using custom JavaScript expressions
- Filter items based on conditions
- Aggregate data (sum, average, group by)
- Run custom scripts for complex transformations

Create `src/nodes/DataProcessor/DataProcessor.node.ts`:

```typescript
import {
  IExecuteFunctions,
  INodeExecutionData,
  INodeType,
  INodeTypeDescription,
} from 'n8n-workflow';

export class DataProcessor implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Data Processor',
    name: 'dataProcessor',
    group: ['transform'],
    version: 1,
    description: 'Process and transform data with custom logic',
    defaults: {
      name: 'Data Processor',
    },
    inputs: ['main'],
    outputs: ['main'],
    properties: [
      {
        displayName: 'Processing Mode',
        name: 'mode',
        type: 'options',
        options: [
          {
            name: 'Transform',
            value: 'transform',
            description: 'Transform data structure',
          },
          {
            name: 'Filter',
            value: 'filter',
            description: 'Filter items based on conditions',
          },
          {
            name: 'Aggregate',
            value: 'aggregate',
            description: 'Aggregate data',
          },
          {
            name: 'Custom Script',
            value: 'script',
            description: 'Run custom JavaScript',
          },
        ],
        default: 'transform',
      },
      {
        displayName: 'Transform Expression',
        name: 'transformExpression',
        type: 'string',
        typeOptions: {
          editor: 'code',
          editorLanguage: 'javascript',
        },
        displayOptions: {
          show: {
            mode: ['transform'],
          },
        },
        default: `// Available variables:
// item - current item
// index - current index
// items - all items

return {
  id: item.json.id,
  name: item.json.name,
  processed: true,
  timestamp: new Date().toISOString()
};`,
        description: 'JavaScript code to transform each item',
      },
      {
        displayName: 'Filter Expression',
        name: 'filterExpression',
        type: 'string',
        typeOptions: {
          editor: 'code',
          editorLanguage: 'javascript',
        },
        displayOptions: {
          show: {
            mode: ['filter'],
          },
        },
        default: `// Return true to keep item, false to filter out
// Available: item, index, items

return item.json.active === true;`,
      },
      {
        displayName: 'Aggregation Type',
        name: 'aggregationType',
        type: 'options',
        displayOptions: {
          show: {
            mode: ['aggregate'],
          },
        },
        options: [
          { name: 'Sum', value: 'sum' },
          { name: 'Average', value: 'average' },
          { name: 'Count', value: 'count' },
          { name: 'Group By', value: 'groupBy' },
          { name: 'Custom', value: 'custom' },
        ],
        default: 'sum',
      },
      {
        displayName: 'Field to Aggregate',
        name: 'aggregateField',
        type: 'string',
        displayOptions: {
          show: {
            mode: ['aggregate'],
            aggregationType: ['sum', 'average'],
          },
        },
        default: 'value',
        description: 'The field to perform aggregation on',
      },
      {
        displayName: 'Group By Field',
        name: 'groupByField',
        type: 'string',
        displayOptions: {
          show: {
            mode: ['aggregate'],
            aggregationType: ['groupBy'],
          },
        },
        default: 'category',
      },
      {
        displayName: 'Custom Script',
        name: 'customScript',
        type: 'string',
        typeOptions: {
          editor: 'code',
          editorLanguage: 'javascript',
        },
        displayOptions: {
          show: {
            mode: ['script'],
          },
        },
        default: `// Full access to items array
// Must return array of items

const processedItems = items.map((item, index) => {
  // Your custom processing logic
  return {
    json: {
      ...item.json,
      processedAt: new Date().toISOString(),
      index: index
    }
  };
});

return processedItems;`,
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const items = this.getInputData();
    const mode = this.getNodeParameter('mode', 0) as string;
    let returnData: INodeExecutionData[] = [];

    switch (mode) {
      case 'transform':
        const transformExpression = this.getNodeParameter('transformExpression', 0) as string;
        returnData = items.map((item, index) => {
          const sandbox = {
            item,
            index,
            items,
          };
          const transformFunction = new Function('item', 'index', 'items', transformExpression);
          const result = transformFunction(item, index, items);
          return { json: result };
        });
        break;

      case 'filter':
        const filterExpression = this.getNodeParameter('filterExpression', 0) as string;
        const filterFunction = new Function('item', 'index', 'items', filterExpression);
        returnData = items.filter((item, index) => filterFunction(item, index, items));
        break;

      case 'aggregate':
        const aggregationType = this.getNodeParameter('aggregationType', 0) as string;

        if (aggregationType === 'sum' || aggregationType === 'average') {
          const field = this.getNodeParameter('aggregateField', 0) as string;
          const values = items.map(item => item.json[field] as number).filter(v => v !== undefined);

          const sum = values.reduce((acc, val) => acc + val, 0);
          const result = aggregationType === 'sum' ? sum : sum / values.length;

          returnData = [{
            json: {
              aggregation: aggregationType,
              field,
              result,
              itemCount: values.length,
            }
          }];
        } else if (aggregationType === 'count') {
          returnData = [{
            json: {
              count: items.length,
            }
          }];
        } else if (aggregationType === 'groupBy') {
          const groupField = this.getNodeParameter('groupByField', 0) as string;
          const groups: { [key: string]: any[] } = {};

          items.forEach(item => {
            const key = item.json[groupField] as string;
            if (!groups[key]) groups[key] = [];
            groups[key].push(item.json);
          });

          returnData = Object.entries(groups).map(([key, values]) => ({
            json: {
              [groupField]: key,
              items: values,
              count: values.length,
            }
          }));
        }
        break;

      case 'script':
        const customScript = this.getNodeParameter('customScript', 0) as string;
        const scriptFunction = new Function('items', customScript);
        const result = scriptFunction(items);
        returnData = Array.isArray(result) ? result : [{ json: result }];
        break;
    }

    return [returnData];
  }
}
```

### Understanding the Data Processor Pattern

This node showcases several important patterns:

**Dynamic Code Execution**: The node allows users to write JavaScript expressions that get executed at runtime. This is incredibly powerful but needs careful handling for security. Notice how we use the `Function` constructor to create sandboxed functions.

**Mode-Based Behavior**: Instead of creating four separate nodes (Transform, Filter, Aggregate, Script), we use a single node with multiple modes. This reduces clutter in the node panel while providing flexibility.

**Aggregation Logic**: The aggregation mode demonstrates how to process entire datasets rather than individual items. This is essential for analytics and reporting workflows.

## Creating Custom Credentials: Securing Your Integrations

Create `src/credentials/CustomApi.credentials.ts`:

```typescript
import {
  ICredentialType,
  INodeProperties,
} from 'n8n-workflow';

export class CustomApi implements ICredentialType {
  name = 'customApi';
  displayName = 'Custom API';
  documentationUrl = 'https://docs.example.com/api';
  properties: INodeProperties[] = [
    {
      displayName: 'API Key',
      name: 'apiKey',
      type: 'string',
      typeOptions: {
        password: true,
      },
      default: '',
      required: true,
    },
    {
      displayName: 'API Secret',
      name: 'apiSecret',
      type: 'string',
      typeOptions: {
        password: true,
      },
      default: '',
    },
    {
      displayName: 'Base URL',
      name: 'baseUrl',
      type: 'string',
      default: 'https://api.example.com',
      placeholder: 'https://api.example.com',
    },
    {
      displayName: 'Environment',
      name: 'environment',
      type: 'options',
      options: [
        { name: 'Production', value: 'production' },
        { name: 'Staging', value: 'staging' },
        { name: 'Development', value: 'development' },
      ],
      default: 'production',
    },
  ];
}
```

### How Credentials Work in n8n

When users add credentials:
1. n8n presents a form based on your `properties` array
2. User enters their credentials (API keys, secrets, etc.)
3. n8n encrypts and stores the credentials securely
4. Your node can access these credentials at runtime using helper methods
5. The credentials are never exposed to the workflow or logs

The `typeOptions: { password: true }` setting ensures sensitive fields are masked in the UI and encrypted in storage. This is critical for security.

## Testing Your Custom Nodes: From Development to Production

Testing is crucial for reliable nodes. Let's set up a comprehensive testing strategy that covers unit tests, integration tests, and debugging techniques.

### 1. Writing Unit Tests

Create `src/nodes/HttpBin/HttpBin.test.ts`:

```typescript
import { HttpBin } from './HttpBin.node';
import { IExecuteFunctions } from 'n8n-workflow';

describe('HttpBin Node', () => {
  let httpBin: HttpBin;
  let executeFunctions: IExecuteFunctions;

  beforeEach(() => {
    httpBin = new HttpBin();
    executeFunctions = {
      getInputData: jest.fn(() => [{ json: { test: 'data' } }]),
      getNodeParameter: jest.fn(),
      helpers: {
        request: jest.fn(),
      },
      continueOnFail: jest.fn(() => false),
      getNode: jest.fn(),
    } as any;
  });

  test('should make GET request', async () => {
    executeFunctions.getNodeParameter = jest.fn()
      .mockReturnValueOnce('request')
      .mockReturnValueOnce('get')
      .mockReturnValueOnce('/get');

    executeFunctions.helpers.request = jest.fn()
      .mockResolvedValue({ success: true });

    const result = await httpBin.execute.call(executeFunctions);

    expect(result).toHaveLength(1);
    expect(result[0]).toHaveLength(1);
    expect(result[0][0].json).toEqual({ success: true });
  });
});
```

### 2. Integration Testing with Your Local n8n

Now let's test your nodes in a real n8n instance:

```bash
# Link your node package locally
cd n8n-nodes-custom
npm link

# Link to n8n
cd ~/.n8n/custom
npm link n8n-nodes-custom

# Restart n8n
n8n start

# Your custom nodes should now appear in the node panel
```

### 3. Debugging Techniques

When things go wrong (and they will), here's how to debug effectively:

```typescript
// Add debug logging to your node
console.log('Debug:', {
  parameter: this.getNodeParameter('mode', 0),
  itemCount: items.length,
});

// Use n8n's logger
this.logger.info('Processing items', { count: items.length });

// Start n8n with debug logging
N8N_LOG_LEVEL=debug n8n start
```

## Publishing Your Nodes: Sharing with the World

Once your nodes are tested and working, you can share them with your team or the community.

### 1. Prepare for Publication

```json
// package.json
{
  "name": "@yourorg/n8n-nodes-custom",
  "version": "1.0.0",
  "description": "Custom n8n nodes for your organization",
  "keywords": [
    "n8n",
    "n8n-node",
    "workflow",
    "automation"
  ],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourorg/n8n-nodes-custom"
  }
}
```

### 2. Publish to npm

```bash
# Build the project
npm run build

# Login to npm
npm login

# Publish
npm publish --access public
```

### 3. Install Your Published Nodes

Users can now install your nodes in their n8n instances:

```bash
# Install globally
npm install -g @yourorg/n8n-nodes-custom

# Or in n8n custom directory
cd ~/.n8n/custom
npm install @yourorg/n8n-nodes-custom
```

## Best Practices

<AccordionGroup>
  <Accordion title="Error Handling">
    Always implement proper error handling:
    ```typescript
    try {
      // Your node logic
    } catch (error) {
      if (this.continueOnFail()) {
        return [{ json: { error: error.message } }];
      }
      throw new NodeOperationError(this.getNode(), error);
    }
    ```
  </Accordion>

  <Accordion title="Performance">
    - Process items in batches when possible
    - Use streaming for large files
    - Implement pagination for API calls
    - Cache frequently accessed data
  </Accordion>

  <Accordion title="Documentation">
    - Add clear descriptions for all parameters
    - Include examples in parameter placeholders
    - Document credential requirements
    - Provide usage examples
  </Accordion>

  <Accordion title="Versioning">
    - Use semantic versioning
    - Maintain backward compatibility
    - Document breaking changes
    - Test migrations thoroughly
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Advanced Node Features" href="./custom-nodes-advanced" icon="rocket">
    Webhooks, polling, and more
  </Card>
  <Card title="Workflow Patterns" href="./workflow-patterns" icon="sitemap">
    Design complex workflows
  </Card>
</CardGroup>