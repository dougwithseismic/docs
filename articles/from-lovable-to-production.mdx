---
title: "From Lovable To Production: A Developer's Guide"
description: "Learn how to transition from Lovable prototyping to production using Turborepo monorepo architecture with Git submodules for seamless collaboration"
icon: "code"
---

_Published: March 26, 2025_

Lovable serves as a fantastic tool for quickly prototyping applications; however, most teams consider it as a temporary solution - build in Lovable first, then completely hand it off to developers to rebuild with traditional coding. But what if you want the collaborative fun to continue?

This guide demonstrates how you can have the best of both worlds by building a Turborepo monorepo architecture around your Lovable application using Git submodules. This powerful approach means:

- Non-technical team members can continue rapidly prototyping and iterating in the Lovable environment they're comfortable with
- Developers can simultaneously build robust production infrastructure around the Lovable app
- Changes sync seamlessly between environments without requiring a complete rebuild
- Your team maintains a collaborative workflow instead of a one-time handoff

The result is a sustainable development process where everyone on your team can contribute effectively using the tools they're most productive with.

## Understanding the Workflow

Before diving into the technical steps, let's understand the overall workflow:

1. **Lovable + GitHub branches for prototyping**:
   - Your team continues to use Lovable for rapid prototyping
   - Changes are made on feature branches, not directly on main
   - Pull requests are created to review changes before merging to main

2. **Turborepo + Submodule for development**:
   - Your Lovable app exists as a Git submodule inside the Turborepo
   - Developers can build around the app (backend, services, packages)
   - The main app lives in the original repo, everything else is built around it

3. **Synchronized development**:
   - Changes to Lovable can still be made through the Lovable interface
   - Technical changes can be made by developers using Cursor or any code editor
   - Both workflows coexist without disrupting each other

This approach gives you the freedom to continue rapid prototyping while simultaneously building production-ready infrastructure.

## Prerequisites

- A Lovable app ready for handoff
- Basic knowledge of Git and GitHub
- Familiarity with monorepo concepts
- Cursor IDE installed (recommended)
- Node.js and pnpm

## The Setup Process

### Step 1: GitHub Integration

First, connect your Lovable app to GitHub:

1. In Lovable, go to your project settings
2. Click "Connect to GitHub"
3. Authorize the GitHub integration
4. Create or link to an existing repository

This creates a bidirectional sync between Lovable and GitHub, allowing changes to flow both ways.

### Step 2: Create Your Turborepo

Create a new repository for your production monorepo:

```bash
npx create-turbo@latest my-production-app
cd my-production-app
```

This gives you a starting point with proper TypeScript configuration, build tools, and workspace structure.

### Step 3: Add Lovable App as Submodule

Add your Lovable app repository as a Git submodule:

```bash
git submodule add https://github.com/yourusername/your-lovable-app.git apps/frontend
git submodule update --init --recursive
```

Your directory structure now looks like:

```
my-production-app/
├── apps/
│   ├── frontend/          # Your Lovable app (submodule)
│   └── docs/             # Documentation app
├── packages/
│   ├── ui/               # Shared UI components
│   └── config/           # Shared config
└── turbo.json
```

### Step 4: Build Production Backend

Create a backend service in your monorepo:

```bash
mkdir apps/backend
cd apps/backend
npm init -y
npm install express cors dotenv
```

Create a simple Express server:

```javascript
// apps/backend/server.js
const express = require('express');
const cors = require('cors');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

app.listen(PORT, () => {
  console.log(`Backend server running on port ${PORT}`);
});
```

### Step 5: Connect Frontend to Backend

Update your Lovable app to use the new backend. Add environment variables to your Lovable app:

```bash
# In apps/frontend/.env
VITE_API_URL=http://localhost:3001
```

Update your API calls in the Lovable app to use the backend:

```javascript
// Example API call in your Lovable app
const fetchData = async () => {
  const response = await fetch(`${import.meta.env.VITE_API_URL}/api/health`);
  const data = await response.json();
  return data;
};
```

### Step 6: Configure Turborepo Scripts

Update your root `package.json` to include build scripts:

```json
{
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "start": "turbo run start"
  }
}
```

Update `turbo.json` to include your apps:

```json
{
  "pipeline": {
    "dev": {
      "cache": false,
      "persistent": true
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "start": {
      "dependsOn": ["build"]
    }
  }
}
```

## Advanced Integration Techniques

### Shared Components

Create shared UI components that both your Lovable app and other apps can use:

```bash
# In packages/ui/
npm init -y
npm install react @types/react
```

Export components from your UI package and import them in your Lovable app for consistency across your monorepo.

### Database Integration

Add a shared database package:

```bash
mkdir packages/database
cd packages/database
npm init -y
npm install prisma @prisma/client
```

This allows all apps in your monorepo to share the same database schema and client.

### Deployment Strategy

Deploy your entire monorepo using Railway or Vercel:

1. **Frontend (Lovable app)**: Deploy as a static site
2. **Backend**: Deploy as a Node.js service
3. **Database**: Use Railway's PostgreSQL or similar

The monorepo structure makes it easy to manage deployments and environment variables across all services.

## Benefits of This Approach

1. **Continuous Collaboration**: Non-technical team members can continue using Lovable while developers build production infrastructure
2. **Gradual Migration**: You can gradually move pieces from Lovable to custom code as needed
3. **Shared Codebase**: All production code lives in one place, making it easier to manage
4. **Version Control**: Everything is properly tracked in Git with clear history
5. **Scalability**: Easy to add new services, packages, and apps as your project grows

## Maintaining the Workflow

### For Lovable Changes

1. Make changes in Lovable interface
2. Lovable automatically pushes to GitHub
3. Pull the latest changes to your submodule:

```bash
cd apps/frontend
git pull origin main
cd ..
git add apps/frontend
git commit -m "Update frontend from Lovable"
```

### For Technical Changes

1. Make changes directly in the code using Cursor or your preferred editor
2. Test locally with the full monorepo setup
3. Push changes to the Lovable repository
4. Changes automatically sync back to Lovable

## Conclusion

This approach bridges the gap between rapid prototyping and production development. Instead of treating Lovable as a throwaway tool, you can build a sustainable development process that leverages the strengths of both visual development and traditional coding.

Your team can continue the collaborative momentum built during the prototyping phase while simultaneously building the robust infrastructure needed for production. The result is faster development cycles, better team collaboration, and a more maintainable codebase.

The key is recognizing that modern development doesn't have to be an either/or choice between visual tools and traditional coding - it can be both, working together in harmony.